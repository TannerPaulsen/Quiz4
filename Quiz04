def twoNorm(vector):
  '''
  twoNorm takes a vector as it's argument. It then computes the sum of  the squares of each element of the vector. It then returns the square root of this sum.
  '''
  # This variable will keep track of the validity of our input.
  inputStatus = True
  # This for loop will check each element of the vector to see if it's a number.
  for i in range(len(vector)):
    if ((type(vector[i]) != int) and (type(vector[i]) != float) and (type(vector[i]) != complex)):
      inputStatus = False
      print("Invalid Input")
  # If the input is valid the function continues to compute the 2-norm
  if inputStatus == True:
    result = 0
# This for loop will compute the sum of the squares of the elements of the vector.
    for i in range(len(vector)):
      result = result + (vector[i]**2)
    result = result**(1/2)
    return result

def qrFact(mat01):
    '''
    This function takes a mat01 as its argument, plugs the vertical vectors 1,2,3 of the 3x3 matrix
    into the above twoNorm function, then normalizes the first vector by what we get from
    the twoNorm for the vec01, then for the next vec02 we take the previous normalized vector
    and divide it by the twoNorm value for vec02 and then we subtract vec02 by that value
    ,a, times the previous normalized vector. We repeat this for the final vector subtravting the last two normalized vectors.
    Then we take resultQ and add each normalized vector to resultQ, however this gives us the transpose not the right resultQ.
    We take resultQ to find R, then we transpose resultQ to get Q.
    :param mat01:
    :return:
    '''

    q = [[0*len(vec01),0,0] for n in mat01]
    a = [0*len(vec02) for n in mat01]
    d = [0*len(vec03) for n in mat01]
    b = [0*len(vec02) for n in mat01]
    c = [0*len(vec03) for n in mat01]
    f = [0*len(vec03) for n in mat01]
    h = len(mat01)
    resultQ = []
    resultR = [[0]*len(mat01) for row in mat01]
    for i in range(h):

        q[i] = vec01[i]/twoNorm(vec01)

        for j in range(h):
            a[j] = (vec02[j]*q[i])*(1/twoNorm(vec02))

            b[j] = vec02[j]-(a[j]*q[i])

            for k in range(h):
                f[k] = (q[i]*vec03[k])/twoNorm(vec03)
                d[k] = (b[j]*vec03[k])/twoNorm(vec03)
                c[k] = vec03[k]-f[k]*q[i]-d[k]*b[j]
    resultQ.append(q)
    resultQ.append(b)
    resultQ.append(c)
    for i in range(len(resultQ)):
        for j in range(len(mat01[0])):
            for k in range(h):

                resultR[i][j] = resultQ[i][j] * mat01[j][k]
    newresultQ = [[0] * len(mat01) for rows in mat01]
    for i in range(len(resultQ)):

        for j in range(len(resultQ[0])):
            newresultQ[i][j] += resultQ[j][i]



    return newresultQ, resultR

matrix = [[1, 2, 1], [0, 1, 1], [1, 0, 1]]
vec01 = [1, 0, 1]
vec02 = [2, 1, 0]
vec03 = [1, 1, 1]

print (qrFact(matrix))
